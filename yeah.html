<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Process Management System Simulator</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="stylesheet" href="st.css">
</head>
<body>
    <header>
        <h1>Process Management System Learning Site</h1>
    </header>

    <main>
        <section id="process-input-section" class="card">
            <h2>Enter Process Details</h2>
            <div id="process-entries-container">
                </div>
            <button id="add-process-btn" class="action-btn">Add Process</button>
            <div class="simulation-options">
                <label for="simulate-deadlock-checkbox">
                    <input type="checkbox" id="simulate-deadlock-checkbox">
                    Simulate Predefined Deadlock Scenario?
                </label>
            </div>
            <button id="run-simulation-btn" class="action-btn primary-btn">Run Simulation & Compare</button>
        </section>

        <section id="results-section" class="card" style="display:none;">
            <h2>Simulation Results</h2>
            
            <div id="loading-spinner" style="display:none; text-align:center; margin: 20px;">
                <div class="spinner"></div>
                <p>Simulating...</p>
            </div>

            <div id="actual-results-content">
                <h3>Comparative Performance Metrics</h3>
                <div class="table-container">
                    <table id="comparison-table">
                        <thead>
                            <tr>
                                <th>Algorithm</th>
                                <th>Avg. Waiting Time</th>
                                <th>Avg. Turnaround Time</th>
                                <th>Avg. Response Time</th>
                                <th>CPU Utilization (%)</th>
                                <th>Throughput (P/unit time)</th>
                                <th>Total Time</th>
                            </tr>
                        </thead>
                        <tbody>
                            </tbody>
                    </table>
                </div>

                <h3>Graphical Comparison</h3>
                <div class="chart-container">
                    <canvas id="waitingTimeChart"></canvas>
                </div>
                <div class="chart-container">
                    <canvas id="turnaroundTimeChart"></canvas>
                </div>
                <div class="chart-container">
                    <canvas id="responseTimeChart"></canvas>
                </div>
                <div class="chart-container">
                    <canvas id="cpuUtilizationChart"></canvas>
                </div>
                <div class="chart-container">
                    <canvas id="throughputChart"></canvas>
                </div>
                
                <h3>Best Algorithm Analysis</h3>
                <div id="best-algo-analysis" class="analysis-box">
                    </div>
                
                <div id="deadlock-results-section" style="display:none;">
                    <h3>Deadlock Analysis</h3>
                    <div id="deadlock-info" class="analysis-box">
                        </div>
                </div>
            </div>
        </section>

        <section id="learning-content" class="card">
            <h2>Learn More About Process Management</h2>
            <div class="learning-grid">
                <article class="learning-article">
                    <h3>Process Management System</h3>
                    <p>A Process Management System is a component of an operating system (OS) that handles the creation, scheduling, execution, and termination of processes. A process is an instance of a program in execution, and managing it is essential to efficiently utilize CPU and system resources.</p>
                    <p><strong>The importance of process management system</strong><br>When managing any organization, it is imperative to understand why process management is essential. More than creating seamless workflows, it enables all business operations to run optimally.<br>
                    With business processes systematically implemented, you reduce time wasted on repetitive tasks and minimize errors due to human inefficiency. Process management also prevents data loss and missed steps within a process. Moreover, it optimizes resource allocation, ensuring your business uses resources efficiently and reduces costs.<br>
                    Process management improves business operations by aligning processes with customers' needs, increasing customer satisfaction and leading to higher revenues.</p>
                </article>

                <article class="learning-article">
                    <h3>Process Creation and Termination</h3>
                    <p>Every program running in a system is a process. When a process is created, the operating system performs several steps: assigns a unique Process ID (PID), allocates memory, creates the Process Control Block (PCB), sets up execution context, and places the process in the ready queue.</p>
                    <p>Processes may be created by system initialization, user requests, batch job submissions, or a parent process using system calls like <code>fork()</code> or <code>createProcess()</code>.</p>
                    <p><strong>Termination:</strong> A process may terminate voluntarily (normal exit), or involuntarily due to errors, resource unavailability, or by a kill command. The OS reclaims all resources, removes the PCB, and updates scheduling queues.</p>
                </article>

                <article class="learning-article">
                    <h3>CPU Scheduling</h3>
                    <p>CPU scheduling is the mechanism by which the OS decides which process in the ready queue gets to use the CPU next. It is essential in multitasking and multiprogramming systems where many processes compete for the CPU.</p>
                    <p><strong>Objectives:</strong> Maximize CPU utilization, minimize response time, ensure fairness, and avoid starvation.</p>
                    <p>Common algorithms include First-Come-First-Served (FCFS), Shortest Job First (SJF), Priority Scheduling, and Round Robin (RR). Scheduling can be <strong>preemptive</strong> (CPU can be taken away) or <strong>non-preemptive</strong> (process runs to completion).</p>
                </article>
                
                <article class="learning-article">
                    <h3>Inter-Process Communication (IPC)</h3>
                    <p>IPC enables processes to communicate and coordinate with each other, especially in concurrent systems. It is necessary when processes depend on each other or need to share data.</p>
                    <p><strong>IPC Methods:</strong></p>
                    <ul>
                        <li><strong>Shared Memory:</strong> Two or more processes access the same memory space. Fast but needs synchronization (e.g., semaphores).</li>
                        <li><strong>Message Passing:</strong> Processes send and receive messages using system calls like <code>send()</code> and <code>receive()</code>. Easier to implement but can be slower than shared memory.</li>
                    </ul>
                    <p>IPC is used in client-server models, producer-consumer problems, and multi-threaded applications.</p>
                </article>

                <article class="learning-article">
                    <h3>Process Synchronization</h3>
                    <p>In concurrent systems, multiple processes or threads may access shared resources like memory or files. Synchronization ensures that they do not corrupt the data or enter inconsistent states.</p>
                    <p><strong>Example:</strong> In a banking system, two transactions updating the same account balance must not execute simultaneously.</p>
                    <p><strong>Techniques:</strong></p>
                    <ul>
                        <li><strong>Mutex Locks:</strong> Allow only one process to enter the critical section at a time.</li>
                        <li><strong>Semaphores:</strong> Counting or binary semaphores manage access to shared resources.</li>
                        <li><strong>Monitors:</strong> High-level abstraction that combines mutual exclusion and condition variables.</li>
                    </ul>
                    <p><strong>Goal:</strong> Prevent race conditions, maintain data consistency, and ensure orderly execution of processes.</p>
                </article>



                <article class="learning-article">
                    <h3>First-Come, First-Served (FCFS)</h3>
                    <p>FCFS is the simplest scheduling algorithm. Processes are dispatched according to their arrival time. The process that arrives first gets the CPU first.</p>
                    <p><strong>Pros:</strong> Simple to understand and implement, fair in the sense that every process eventually runs.</p>
                    <p><strong>Cons:</strong> Can lead to the "convoy effect," where short processes get stuck waiting for long ones if a long process arrives first. Not ideal for interactive systems as average waiting time can be high.</p>
                </article>
                <article class="learning-article">
                    <h3>Shortest Job First (SJF)</h3>
                    <p>SJF selects the process with the smallest CPU burst time next. It can be preemptive (Shortest Remaining Time First - SRTF) or non-preemptive.</p>
                    <p><strong>Pros:</strong> Provably optimal in minimizing average waiting time for a given set of processes (for non-preemptive).</p>
                    <p><strong>Cons:</strong> Requires knowing the burst time in advance (often not possible). Can lead to starvation for long processes if short processes keep arriving.</p>
                </article>
                <article class="learning-article">
                    <h3>Priority Scheduling</h3>
                    <p>Each process is assigned a priority, and the CPU is allocated to the process with the highest priority. Can be preemptive or non-preemptive.</p>
                    <p><strong>Pros:</strong> Allows for important processes to be run sooner.</p>
                    <p><strong>Cons:</strong> Can lead to starvation for low-priority processes. Aging can be used to mitigate this by gradually increasing the priority of waiting processes.</p>
                </article>
                <article class="learning-article">
                    <h3>Round Robin (RR)</h3>
                    <p>Designed for time-sharing systems. Each process gets a small unit of CPU time (time quantum or time slice). After this time has elapsed, the process is preempted and added to the end of the ready queue.</p>
                    <p><strong>Pros:</strong> Fair, provides good response time for interactive users. No starvation.</p>
                    <p><strong>Cons:</strong> Performance depends heavily on the time quantum. Too small leads to high context switching overhead; too large behaves like FCFS.</p>
                </article>
                <article class="learning-article">
                    <h3>Deadlocks</h3>
                    <p>A deadlock is a state in which each member of a group of processes is waiting for some other member to release a resource, and none can proceed.</p>
                    <h4>Necessary Conditions for Deadlock:</h4>
                    <ul>
                        <li><strong>Mutual Exclusion:</strong> At least one resource must be held in a non-sharable mode.</li>
                        <li><strong>Hold and Wait:</strong> A process must be holding at least one resource and waiting to acquire additional resources that are currently being held by other processes.</li>
                        <li><strong>No Preemption:</strong> Resources cannot be preempted; a resource can only be released voluntarily by the process holding it.</li>
                        <li><strong>Circular Wait:</strong> A set of waiting processes {P0, P1, ..., Pn} must exist such that P0 is waiting for a resource held by P1, P1 is waiting for a resource held by P2, ..., Pn-1 is waiting for Pn, and Pn is waiting for a resource held by P0.</li>
                    </ul>
                    <p><strong>Techniques:</strong></p>
                    <ul>
                        <li><strong>Prevention:</strong> Design the system to ensure at least one of the deadlock conditions cannot hold.</li>
                        <li><strong>Avoidance:</strong> Use algorithms like <em>Banker’s Algorithm</em> to ensure a safe resource allocation state.</li>
                        <li><strong>Detection and Recovery:</strong> Allow deadlocks to occur, detect them using resource allocation graphs, and recover by terminating or rolling back processes.</li>
                        <li><strong>Ignore:</strong> In some systems, deadlocks are rare and handled by rebooting (Ostrich Algorithm).</li>
                    </ul>
                    <p>Deadlocks can be prevented, avoided, detected and recovered from, or ignored (the "Ostrich Algorithm").</p>
                </article>
            </div>
        </section>
    </main>

    <footer>
        <p>© 2023 Process Management Learning Site</p>
    </footer>

    <script src="sc.js">
    </script>
</body>
</html>